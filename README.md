# httpzip

Основная идея: возможность быстро подключить zip-файл в качестве каталога со статическими файлами и отдавать их через стандартный Go HTTP-сервер. Специально для этого и реализована поддержка функции, аналогичной `http.ServeFile`.

```go
// Открываем файл с архивом
zipServer, err := httpzip.Open("static.zip")
if err != nil {
    log.Fatal(err)
}
defer zipServer.Close() // Атоматически закрываем по окончании

// Инициализируем обработчик HTTP-запросов
http.HandleFunc("/static/", func(w http.ResponseWriter, r *http.Request) {
    name := strings.TrimPrefix(r.URL.Path, "/static/")
    zipServer.ServeFile(w, r, name)
})
```

`ServeFile` позволяет отдать файл с указанным именем в HTTP-поток: в общем, ради этой функции все и писалось. 

При отдаче заголовок `Last-Modified` устанавливается в значение времени последней модификации файла с архивом. Кроме этого, корректно возвращается Content-Type в зависимости от расширения файла. Функция обрабатывает только __GET__ или __HEAD__ запросы. В противном случае будет возвращена ошибка `http.StatusMethodNotAllowed` с корректно установленными HTTP-заголовками. Если файла с указанным именем в архиве не найдено, то будет возвращена ошибка
`http.StatusNotFound`. При обработке запроса обрабатывается заголовок `If-Modified-Since` и, если файл не изменился, возвращается `http.StatusNotModified`.

Ну и последнее замечание: данный класс умеет проверять, что самый первый файл имеет имя `mimetype` и его содержимое совпадает с указанным в параметре вызова функции `CheckMimeType`. В общем-то, это, в первую очередь, сделано под влиянием формата EPUB, где таким образом определяется, что архив содержит книгу еще до непосредственно распаковки архива. Здесь это является не обязательным: просто бесплатное добавление.

Из мелочей: вы можете легко загрузить содержимое любого файла или открыть его как поток на чтение. Но это уже так — приятности, не более.

```go
// Читаем из него, например, шаблон и разбираем его, если это нужно
data, err := zipServer.GetData("templates/default.tmpl")
if err != nil {
    log.Fatal(err)
}
tmpl, err = template.New("").Parse(string(data))
if err != nil {
    log.Fatal(err)
}
```

Остальное — "читайте мои мемуары", как говорил один мой преподаватель, подразумевая, что хорошо бы заглянуть в его методичку.


## zipcompiler

Для облегчения жизни себе и окружающим, в подкаталоге __zipcompiler__ лежат исходники упаковщика в формат zip. Обычно он на фиг не нужен, но этот поддерживает несколько, лично для меня, полезных функций:

1. Позволяет автоматически добавить первым и без сжатия файл с именем `mimetype`, в качестве содержимого которого можно указать любую строку (см. описание `CheckMimeType` выше).
2. Поддерживает автоматическую минимизацию файлов в формате CSS, JavaScript и HTML при их упаковке.

